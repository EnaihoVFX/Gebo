import { invoke } from "@tauri-apps/api/core";
import { type Probe } from "./ffmpeg";

// JSON-based project schema - single source of truth
export interface ProjectData {
  metadata: {
    title: string;
    version: string;
    createdAt: string;
    lastModified: string;
    description?: string;
  };
  settings: {
    timelineSettings: {
      frameRate: number;
      resolution: {
        width: number;
        height: number;
      };
      duration: number;
    };
    exportSettings: {
      format: string;
      quality: string;
      codec: string;
    };
  };
  mediaFiles: MediaFileData[];
  tracks: TrackData[];
  clips: ClipData[];
  timeline: {
    currentTime: number;
    zoom: number;
    pan: number;
    selectedClipId?: string;
    inOutPoints: {
      in: number | null;
      out: number | null;
    };
  };
}

export interface MediaFileData {
  id: string;
  name: string;
  path: string;
  type: "video" | "audio" | "image";
  probe: Probe;
  duration: number;
  width?: number;
  height?: number;
  peaks?: number[];
  thumbnails?: string[];
  thumbnailUrl?: string;
  // Metadata for AI operations
  metadata?: {
    tags?: string[];
    description?: string;
    aiNotes?: string;
  };
}

export interface TrackData {
  id: string;
  name: string;
  type: "video" | "audio" | "text" | "effect";
  enabled: boolean;
  muted: boolean;
  volume: number; // 0-100
  order: number;
  // AI metadata
  aiMetadata?: {
    purpose?: string;
    notes?: string;
    autoGenerated?: boolean;
  };
}

export interface ClipData {
  id: string;
  mediaFileId: string;
  name: string;
  // Timeline positioning
  offset: number; // Start time on timeline
  // Content positioning within the media file
  startTime: number; // Start time within the media file
  endTime: number;   // End time within the media file
  trackId: string;
  // Visual properties
  opacity?: number;
  volume?: number;
  // AI metadata
  aiMetadata?: {
    description?: string;
    tags?: string[];
    autoGenerated?: boolean;
    aiNotes?: string;
  };
}

// Project manager class
export class ProjectManager {
  private projectData: ProjectData | null = null;
  private listeners: Set<(data: ProjectData) => void> = new Set();

  constructor() {
    this.initializeProject();
  }

  private initializeProject(): void {
    this.projectData = {
      metadata: {
        title: "Untitled Project",
        version: "1.0.0",
        createdAt: new Date().toISOString(),
        lastModified: new Date().toISOString(),
      },
      settings: {
        timelineSettings: {
          frameRate: 30,
          resolution: { width: 1920, height: 1080 },
          duration: 0,
        },
        exportSettings: {
          format: "mp4",
          quality: "high",
          codec: "h264",
        },
      },
      mediaFiles: [],
      tracks: [
        {
          id: 'video-1',
          name: 'Video Track 1',
          type: 'video',
          enabled: true,
          muted: false,
          volume: 100,
          order: 0,
        },
        {
          id: 'audio-1',
          name: 'Audio Track 1',
          type: 'audio',
          enabled: true,
          muted: false,
          volume: 100,
          order: 1,
        },
      ],
      clips: [],
      timeline: {
        currentTime: 0,
        zoom: 1,
        pan: 0,
        inOutPoints: { in: null, out: null },
      },
    };
  }

  // Subscribe to project changes
  subscribe(listener: (data: ProjectData) => void): () => void {
    this.listeners.add(listener);
    // Immediately call with current data
    if (this.projectData) {
      listener(this.projectData);
    }
    // Return unsubscribe function
    return () => this.listeners.delete(listener);
  }

  // Get current project data
  getProjectData(): ProjectData | null {
    return this.projectData;
  }

  // Update project data and notify listeners
  private updateProject(updates: Partial<ProjectData>): void {
    if (!this.projectData) return;

    this.projectData = {
      ...this.projectData,
      ...updates,
      metadata: {
        ...this.projectData.metadata,
        lastModified: new Date().toISOString(),
        ...(updates.metadata || {}),
      },
    };

    // Notify all listeners
    this.listeners.forEach(listener => listener(this.projectData!));
  }

  // Media file operations
  addMediaFile(mediaFile: MediaFileData): void {
    if (!this.projectData) return;
    
    this.updateProject({
      mediaFiles: [...this.projectData.mediaFiles, mediaFile],
    });
  }

  removeMediaFile(mediaFileId: string): void {
    if (!this.projectData) return;
    
    this.updateProject({
      mediaFiles: this.projectData.mediaFiles.filter(mf => mf.id !== mediaFileId),
      clips: this.projectData.clips.filter(clip => clip.mediaFileId !== mediaFileId),
    });
  }

  // Track operations
  addTrack(track: TrackData): void {
    if (!this.projectData) return;
    
    this.updateProject({
      tracks: [...this.projectData.tracks, track],
    });
  }

  updateTrack(trackId: string, updates: Partial<TrackData>): void {
    if (!this.projectData) return;
    
    this.updateProject({
      tracks: this.projectData.tracks.map(track =>
        track.id === trackId ? { ...track, ...updates } : track
      ),
    });
  }

  removeTrack(trackId: string): void {
    if (!this.projectData) return;
    
    this.updateProject({
      tracks: this.projectData.tracks.filter(track => track.id !== trackId),
      clips: this.projectData.clips.filter(clip => clip.trackId !== trackId),
    });
  }

  // Clip operations
  addClip(clip: ClipData): void {
    if (!this.projectData) return;
    
    this.updateProject({
      clips: [...this.projectData.clips, clip],
    });
  }

  updateClip(clipId: string, updates: Partial<ClipData>): void {
    if (!this.projectData) return;
    
    this.updateProject({
      clips: this.projectData.clips.map(clip =>
        clip.id === clipId ? { ...clip, ...updates } : clip
      ),
    });
  }

  removeClip(clipId: string): void {
    if (!this.projectData) return;
    
    this.updateProject({
      clips: this.projectData.clips.filter(clip => clip.id !== clipId),
    });
  }

  // Timeline operations
  updateTimeline(updates: Partial<ProjectData['timeline']>): void {
    if (!this.projectData) return;
    
    this.updateProject({
      timeline: {
        ...this.projectData.timeline,
        ...updates,
      },
    });
  }

  // AI-friendly operations
  splitClip(clipId: string, splitTime: number): void {
    const clip = this.projectData?.clips.find(c => c.id === clipId);
    if (!clip) return;

    const clipStart = clip.offset;
    const clipEnd = clip.offset + (clip.endTime - clip.startTime);
    const relativeSplitTime = Math.max(clipStart, Math.min(splitTime, clipEnd));
    
    const clipDuration = clip.endTime - clip.startTime;
    const clipProgress = (relativeSplitTime - clipStart) / clipDuration;
    const splitPositionInClip = clip.startTime + (clipProgress * clipDuration);

    const firstSegment: ClipData = {
      ...clip,
      id: `${clip.id}_1`,
      name: `${clip.name} (Part 1)`,
      endTime: splitPositionInClip,
    };

    const secondSegment: ClipData = {
      ...clip,
      id: `${clip.id}_2`,
      name: `${clip.name} (Part 2)`,
      startTime: splitPositionInClip,
      offset: relativeSplitTime,
    };

    this.updateProject({
      clips: [
        ...this.projectData.clips.filter(c => c.id !== clipId),
        firstSegment,
        secondSegment,
      ],
    });
  }

  resizeClip(clipId: string, newStartTime: number, newEndTime: number): void {
    const clip = this.projectData?.clips.find(c => c.id === clipId);
    if (!clip) return;

    const clipDuration = clip.endTime - clip.startTime;
    const startProgress = (newStartTime - clip.offset) / clipDuration;
    const endProgress = (newEndTime - clip.offset) / clipDuration;
    
    const newStartTimeInClip = clip.startTime + (startProgress * clipDuration);
    const newEndTimeInClip = clip.startTime + (endProgress * clipDuration);

    this.updateClip(clipId, {
      startTime: Math.max(clip.startTime, newStartTimeInClip),
      endTime: Math.min(clip.endTime, newEndTimeInClip),
      offset: newStartTime,
    });
  }

  // AI operations for direct timeline manipulation
  aiAddClip(mediaFileId: string, trackId: string, offset: number, startTime: number, endTime: number, options?: {
    name?: string;
    description?: string;
    tags?: string[];
  }): void {
    const mediaFile = this.projectData?.mediaFiles.find(mf => mf.id === mediaFileId);
    if (!mediaFile) return;

    const clip: ClipData = {
      id: `ai_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      mediaFileId,
      name: options?.name || mediaFile.name,
      offset,
      startTime,
      endTime,
      trackId,
      aiMetadata: {
        description: options?.description,
        tags: options?.tags,
        autoGenerated: true,
        aiNotes: `Added by AI at ${new Date().toISOString()}`,
      },
    };

    this.addClip(clip);
  }

  aiMoveClip(clipId: string, newOffset: number): void {
    this.updateClip(clipId, { offset: newOffset });
  }

  aiTrimClip(clipId: string, newStartTime: number, newEndTime: number): void {
    this.updateClip(clipId, { startTime: newStartTime, endTime: newEndTime });
  }

  // Export project to JSON
  exportToJSON(): string {
    return JSON.stringify(this.projectData, null, 2);
  }

  // Import project from JSON
  importFromJSON(jsonString: string): void {
    try {
      const data = JSON.parse(jsonString) as ProjectData;
      this.projectData = data;
      this.listeners.forEach(listener => listener(this.projectData!));
    } catch (error) {
      console.error('Failed to import project from JSON:', error);
    }
  }

  // Save/load from file system (using Tauri)
  async saveToFile(filePath: string): Promise<void> {
    if (!this.projectData) return;
    
    try {
      await invoke('write_text_file', {
        path: filePath,
        contents: this.exportToJSON(),
      });
    } catch (error) {
      console.error('Failed to save project:', error);
      throw error;
    }
  }

  async loadFromFile(filePath: string): Promise<void> {
    try {
      const content = await invoke('read_text_file', { path: filePath }) as string;
      this.importFromJSON(content);
    } catch (error) {
      console.error('Failed to load project:', error);
      throw error;
    }
  }
}

// Global project manager instance
export const projectManager = new ProjectManager();


